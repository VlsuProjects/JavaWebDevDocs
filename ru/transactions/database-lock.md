# Блокирование базы данных транзакциями

Очевидно, что использование транзакций затрагивает базу данных и во время выполнения транзакции база данных может быть
заблокирована. В этом уроке мы рассмотрим, как транзакции блокируют базу данных, а также когда блокировкой можно
управлять вручную.

## Блокировка базы данных

Когда транзакция начинается, она блокирует ресурсы, которые она хочет изменить. Это делается для того, чтобы другие
транзакции не могли изменить те же ресурсы в то же время, что может вызвать проблемы с целостностью данных. Когда
транзакция завершается, блокировка снимается.

Существует несколько уровней блокировки, которые можно использовать в зависимости от требований приложения. Например,
можно использовать блокировку на уровне строки, чтобы заблокировать только одну строку, или блокировку на уровне
таблицы,
чтобы заблокировать всю таблицу.

## Уровни блокировки

Существует четыре уровня блокировки, которые можно использовать в зависимости от требований приложения:

- **Read Uncommitted**: Этот уровень блокировки позволяет транзакции читать данные, которые были изменены другой
  транзакцией, но еще не были зафиксированы. Это самый низкий уровень блокировки и он не гарантирует целостность данных.
- **Read Committed**: Этот уровень блокировки позволяет транзакции читать только те данные, которые были зафиксированы.
- **Repeatable Read**: Этот уровень блокировки гарантирует, что транзакция будет видеть те же данные во время всей
  транзакции. Это означает, что другие транзакции не смогут изменить данные, которые читает транзакция.
- **Serializable**: Этот уровень блокировки гарантирует, что транзакция будет видеть те же данные во время всей
  транзакции и другие транзакции не смогут изменить данные, которые читает транзакция.

Что означают эти уровни блокировки? Давайте рассмотрим пример:

```java
@Transactional(isolation = Isolation.READ_COMMITTED)
public void transferMoney(Long fromAccountId, Long toAccountId, BigDecimal amount) {
    Account fromAccount = accountRepository.findById(fromAccountId).orElseThrow();
    Account toAccount = accountRepository.findById(toAccountId).orElseThrow();

    if (fromAccount.getBalance().compareTo(amount) < 0) {
        throw new IllegalArgumentException("Not enough money on account");
    }

    fromAccount.setBalance(fromAccount.getBalance().subtract(amount));
    toAccount.setBalance(toAccount.getBalance().add(amount));

    accountRepository.save(fromAccount);
    accountRepository.save(toAccount);
}
```

В этом примере мы используем уровень блокировки `READ_COMMITTED`, позволяющий читать только те данные,
которые были зафиксированы. Это означает, что другие транзакции не смогут изменить данные, которые читает транзакция.

Если бы мы использовали уровень блокировки `READ_UNCOMMITTED`, то транзакция могла бы читать данные, которые были
изменены другой транзакцией, но еще не были зафиксированы. Это может привести к проблемам с целостностью данных, но 
повысить производительность.

## Управление блокировкой

Обычно блокировками данных управляет сама база данных или Spring Transaction Manager. Но иногда бывает полезно
управлять блокировками вручную для повышения производительности или избежания проблем с целостностью данных.

# [**Следующий урок**: *Использование транзакций в приложении*](usage.md)
